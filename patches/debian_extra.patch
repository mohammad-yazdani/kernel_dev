diff --git a/net/core/sock.c b/net/core/sock.c
index 873601f3cdea..441f6783a921 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -2822,6 +2822,9 @@ static void sock_def_readable(struct sock *sk)
 	rcu_read_unlock();
 }
 
+// A modified version of @sock_def_readable which emits spurious events
+// to epoll. In this context spurious events are when a write to a non-empty buffer
+// wakes a waiter. (concerns user-level threading).
 static void sock_def_readable_no_spur(struct sock *sk, unsigned int prev_buff_sz)
 {
 	struct socket_wq *wq;
@@ -2829,9 +2832,15 @@ static void sock_def_readable_no_spur(struct sock *sk, unsigned int prev_buff_sz
 
 	rcu_read_lock();
 	wq = rcu_dereference(sk->sk_wq);
-	if (skwq_has_sleeper(wq) && !(sk->sk_type == SOCK_STREAM && prev_buff_sz > 0 && net->ipv4.sysctl_tcp_spurious_wake == 1)) {
-		printk("SPUR WAKE: %d\n", net->ipv4.sysctl_tcp_spurious_wake);
-		wake_up_interruptible_sync_poll(&wq->wait, EPOLLIN | EPOLLPRI |	EPOLLRDNORM | EPOLLRDBAND);
+	int spurious_wake = sk->sk_type == SOCK_STREAM && prev_buff_sz > 0 && net->ipv4.sysctl_tcp_spurious_wake == 1;
+	if (skwq_has_sleeper(wq) ) {
+		if (sk->sk_type == SOCK_STREAM && prev_buff_sz > 0 && net->ipv4.sysctl_tcp_spurious_wake == 0) {
+			// Spurious wake
+			rcu_read_unlock();
+			return;
+		} else {
+			wake_up_interruptible_sync_poll(&wq->wait, EPOLLIN | EPOLLPRI |	EPOLLRDNORM | EPOLLRDBAND);
+		}
 	}
 
 	sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
